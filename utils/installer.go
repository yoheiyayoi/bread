package utils

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"sync"
	"sync/atomic"
	"time"
	"yoheiyayoi/bread/breadTypes"

	"github.com/BurntSushi/toml"
	"github.com/charmbracelet/log"
)

// Helper struct for installation state
type installSession struct {
	wg               sync.WaitGroup
	installed        sync.Map // concurrent map for visited packages
	errChan          chan error
	successCount     atomic.Int32
	totalCount       atomic.Int32
	lockfilePackages sync.Map // map[string]*breadTypes.LockedPackage
}

func newInstallSession() *installSession {
	return &installSession{
		errChan: make(chan error, 1000),
	}
}

func (s *installSession) Go(fn func()) {
	s.wg.Add(1)
	go func() {
		defer s.wg.Done()
		fn()
	}()
}

func (ic *InstallationContext) Install() error {
	start := time.Now()
	session := newInstallSession()

	// Create directories and install packages for each realm
	realms := []struct {
		realm Realm
		deps  map[string]string
	}{
		{RealmShared, ic.Manifest.Dependencies},
		{RealmServer, ic.Manifest.ServerDependencies},
		{RealmDev, ic.Manifest.DevDependencies},
	}

	log.Info("Installing packages...")

	// 1. Download Phase
	for _, r := range realms {
		if len(r.deps) == 0 {
			continue
		}

		// Create index directory
		if err := os.MkdirAll(ic.getIndexDir(r.realm), 0755); err != nil {
			return err
		}

		// Download packages recursively
		for name, versionSpec := range r.deps {
			ic.installPackageRecursive(name, versionSpec, r.realm, session)
		}
	}

	session.wg.Wait()
	close(session.errChan)

	// Check for errors
	for err := range session.errChan {
		if err != nil {
			return err
		}
	}

	// Write lockfile
	var lockedPackages []breadTypes.LockedPackage
	session.lockfilePackages.Range(func(key, value interface{}) bool {
		lockedPackages = append(lockedPackages, *value.(*breadTypes.LockedPackage))
		return true
	})

	// Add root package
	rootDeps := [][]string{}
	// Combine all dependencies for root package
	for name, spec := range ic.Manifest.Dependencies {
		rootDeps = append(rootDeps, []string{name, spec})
	}
	for name, spec := range ic.Manifest.ServerDependencies {
		rootDeps = append(rootDeps, []string{name, spec})
	}
	for name, spec := range ic.Manifest.DevDependencies {
		rootDeps = append(rootDeps, []string{name, spec})
	}
	sort.Slice(rootDeps, func(i, j int) bool {
		return rootDeps[i][0] < rootDeps[j][0]
	})

	lockedPackages = append(lockedPackages, breadTypes.LockedPackage{
		Name:         ic.Manifest.Package.Name,
		Version:      ic.Manifest.Package.Version,
		Dependencies: rootDeps,
	})

	// Sort packages by name
	sort.Slice(lockedPackages, func(i, j int) bool {
		return lockedPackages[i].Name < lockedPackages[j].Name
	})

	newLockfile := breadTypes.Lockfile{
		Registry: ic.Manifest.Package.Registry,
		Packages: lockedPackages,
	}

	lockPath := filepath.Join(ic.ProjectPath, "bread.lock")
	f, err := os.Create(lockPath)
	if err != nil {
		return fmt.Errorf("failed to create lockfile: %w", err)
	}
	defer f.Close()

	if _, err := f.WriteString("# This file is automatically @generated by Bread.\n# It is not intended for manual editing.\n\n"); err != nil {
		return fmt.Errorf("failed to write lockfile header: %w", err)
	}

	encoder := toml.NewEncoder(f)
	if err := encoder.Encode(newLockfile); err != nil {
		return fmt.Errorf("failed to write lockfile: %w", err)
	}

	// 2. Linking Phase
	for _, r := range realms {
		if len(r.deps) > 0 {
			if err := ic.writeRootPackageLinks(r.realm, r.deps); err != nil {
				return err
			}
		}
	}

	elapsed := time.Since(start)
	log.Infof("%s Installed %d packages in %dms", Check, session.successCount.Load(), elapsed.Milliseconds())
	return nil
}

func (ic *InstallationContext) installPackageRecursive(name, versionSpec string, realm Realm, session *installSession) {
	pkgName, versionConstraint := parsePackageSpec(name, versionSpec)

	var version string
	var err error

	// Check lockfile first
	if lockedVersions, ok := ic.Lockfile[pkgName]; ok {
		for _, lockedPkg := range lockedVersions {
			if MatchConstraint(lockedPkg.Version, versionConstraint) {
				version = lockedPkg.Version
				break
			}
		}
	}

	if version == "" {
		// Resolve version constraint to concrete version
		version, err = ResolveVersion(pkgName, versionConstraint)
		if err != nil {
			session.errChan <- fmt.Errorf("failed to resolve version for %s@%s: %v", pkgName, versionConstraint, err)
			return
		}
	}

	pkgID := fmt.Sprintf("%s:%s@%s", realm, pkgName, version)

	// Check if already installed/processing
	if _, loaded := session.installed.LoadOrStore(pkgID, true); loaded {
		return
	}

	session.totalCount.Add(1)
	session.Go(func() {
		if err := ic.downloadPackage(pkgName, version, realm); err != nil {
			session.errChan <- err
			return
		}

		// Log success only
		fmt.Printf("%s Downloaded %s@%s\n", Check, pkgName, version)
		session.successCount.Add(1)

		// Read dependencies from the downloaded package
		deps, err := ic.getPackageDependencies(pkgName, version, realm)
		if err != nil {
			log.Errorf("Failed to read dependencies for %s@%s: %v", pkgName, version, err)
			return
		}

		// Store in lockfile packages
		depsList := [][]string{}
		for alias, spec := range deps {
			depsList = append(depsList, []string{alias, spec})
		}
		sort.Slice(depsList, func(i, j int) bool {
			return depsList[i][0] < depsList[j][0]
		})

		session.lockfilePackages.Store(pkgName+"@"+version, &breadTypes.LockedPackage{
			Name:         pkgName,
			Version:      version,
			Dependencies: depsList,
		})

		for depName, depVersion := range deps {
			ic.installPackageRecursive(depName, depVersion, realm, session)
		}
	})
}

func (ic *InstallationContext) InstallSinglePackage(name, versionSpec string, realm Realm) error {
	start := time.Now()

	// Create index directory
	if err := os.MkdirAll(ic.getIndexDir(realm), 0755); err != nil {
		return err
	}

	// Parse and download the package
	pkgName, versionConstraint := parsePackageSpec(name, versionSpec)
	version, err := ResolveVersion(pkgName, versionConstraint)
	if err != nil {
		return err
	}

	if err := ic.downloadPackage(pkgName, version, realm); err != nil {
		return err
	}

	// Write root package link for this single package
	baseDir := ic.getRealmDir(realm)
	if err := os.MkdirAll(baseDir, 0755); err != nil {
		return err
	}

	if err := ic.writeLinkFile(baseDir, pkgName, version, realm); err != nil {
		return err
	}

	fmt.Printf("%s Downloaded %s@%s\n", Check, pkgName, version)

	elapsed := time.Since(start)
	log.Infof("%s Installed %s@%s in %dms", Check, pkgName, version, elapsed.Milliseconds())
	return nil
}
